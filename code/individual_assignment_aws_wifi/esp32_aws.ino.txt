/* Wi-Fi STA Connect and Disconnect Example

   This example code is in the Public Domain (or CC0 licensed, at your option.)

   Unless required by applicable law or agreed to in writing, this
   software is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR
   CONDITIONS OF ANY KIND, either express or implied.

*/
#include <stdio.h>
#include "freertos/FreeRTOS.h"
#include "freertos/task.h"
#include <WiFiClientSecure.h>
#include <PubSubClient.h>
#include <WiFi.h>
#include <ArduinoJson.h>
#include "secrets.h"

#define WIFI_MAX_RETRIES 20
#define RETRY_DELAY 2000 / portTICK_PERIOD_MS
#define MQTT_LOOP 1000 / portTICK_PERIOD_MS

#define BASELINE_VALUE 50    // Fixed base value
#define NOISE_LEVEL 5           // Max noise deviation

// The MQTT topics that this device should publish/subscribe
#define AWS_IOT_PUBLISH_TOPIC   "esp32/pub"
#define AWS_IOT_SUBSCRIBE_TOPIC "esp32/sub"

TaskHandle_t task_wifi = NULL;
TaskHandle_t task_mqtt = NULL;
TaskHandle_t task_publish = NULL;

WiFiClientSecure net = WiFiClientSecure();
PubSubClient client(net);

void connect_wifi(void *arg) {
  printf("\n[WiFi] Connecting to %s\n", WIFI_SSID);

  WiFi.begin(WIFI_SSID, WIFI_PASSWORD);
  // Auto reconnect is set true as default
  // To set auto connect off, use the following function
  //    WiFi.setAutoReconnect(false);

  // Will try for about 10 seconds (20x 500ms)
  int numberOfTries = WIFI_MAX_RETRIES;

  // Wait for the WiFi event
  while (true) {

    switch (WiFi.status()) {
      case WL_NO_SSID_AVAIL: 
        printf("[WiFi] SSID not found\n"); 
        break;

      case WL_CONNECT_FAILED:
        printf("[WiFi] Failed - WiFi not connected! \n");
        vTaskDelete(NULL); 
        break;

      case WL_CONNECTION_LOST: 
        printf("[WiFi] Connection was lost\n"); 
        break;

      case WL_SCAN_COMPLETED:  
        printf("[WiFi] Scan is completed\n"); 
        break;

      case WL_DISCONNECTED:    
        printf("[WiFi] WiFi is disconnected\n"); 
        break;

      case WL_CONNECTED:
        printf("[WiFi] WiFi is connected!\n");
        printf("[WiFi] IP address: %d.%d.%d.%d\n", WiFi.localIP() & 0xFF, 
                  (WiFi.localIP() >> 8) & 0xFF, 
                  (WiFi.localIP() >> 16) & 0xFF, 
                  (WiFi.localIP() >> 24) & 0xFF);

        xTaskCreate(connect_mqtt, "task_mqtt", 8192, NULL, 5, &task_mqtt);
        vTaskDelete(NULL); 
        break;

      default:
        printf("[WiFi] WiFi Status: %d\n", WiFi.status());
        break;
    }
    vTaskDelay(RETRY_DELAY);

    if (numberOfTries <= 0) {
      printf("[WiFi] Failed to connect to WiFi!\n");
      // Use disconnect function to force stop trying to connect
      WiFi.disconnect();
      vTaskDelete(NULL); 
    } else {
      numberOfTries--;
    }
  }
}

void connect_mqtt(void *arg) {
  printf("\n[MQTT] Connecting to %s\n", AWS_IOT_ENDPOINT);

  // Configure WiFiClientSecure to use the AWS IoT device credentials
  net.setCACert(AWS_CERT_CA);
  net.setCertificate(AWS_CERT_CRT);
  net.setPrivateKey(AWS_CERT_PRIVATE);

  // Connect to the MQTT broker on the AWS endpoint we defined earlier
  client.setServer(AWS_IOT_ENDPOINT, 8883);
  client.setCallback(message_receive);

  printf("[MQTT] Connecting to mqtt broker\n");
  while (!client.connect(THINGNAME)) {
    printf(".");
    vTaskDelay(RETRY_DELAY);
  }

  if (!client.connected()) {
    printf("[MQTT] AWS IoT Timeout\n");
    vTaskDelete(NULL);     
  }

  printf("[MQTT] Connected\n");

  // start publishing values
  xTaskCreate(message_publish, "task_publish", 4096, NULL, 10, &task_publish);

  // Subscribe to a topic
  printf("[MQTT] subscribe to topic: %s\n", AWS_IOT_SUBSCRIBE_TOPIC);
  client.subscribe(AWS_IOT_SUBSCRIBE_TOPIC);

  while (1) {
    client.loop();
    vTaskDelay(MQTT_LOOP);
  }

  vTaskDelete(NULL); 
}

void message_publish(void *arg){
  vTaskDelay(RETRY_DELAY);

  while (1) {
    // Generate a value centered around BASELINE_DISTANCE with a random noise component
    float value = BASELINE_VALUE + random(-NOISE_LEVEL, NOISE_LEVEL + 1);

    StaticJsonDocument<200> doc;
    doc["mytime"] = millis();
    doc["device"] = 1;
    doc["value"] = value;
    char jsonBuffer[512];
    serializeJson(doc, jsonBuffer); // print to client

    if (client.publish(AWS_IOT_PUBLISH_TOPIC, jsonBuffer)) {
      printf("[MQTT] publishing message to topic: %s\n%s\n", AWS_IOT_PUBLISH_TOPIC, jsonBuffer);

    } else {
      printf("[MQTT] error publishing message to topic: %s\n", AWS_IOT_PUBLISH_TOPIC);
      if (!client.connected()) {
        printf("[MQTT] AWS IoT Timeout\n");
        vTaskDelete(NULL); 
      }
    }

    vTaskDelay(RETRY_DELAY);
  }
}

void message_receive(char* topic, byte* payload, unsigned int length) {
  StaticJsonDocument<200> doc;
  deserializeJson(doc, payload);
  const char* message = doc["message"];
  printf("[MQTT] incoming topic: %s\n%s\n", topic, message);
  // Note: Do not use the client in the callback to publish, subscribe or
  // unsubscribe as it may cause deadlocks when other things arrive while
  // sending and receiving acknowledgments. Instead, change a global variable,
  // or push to a queue and handle it in the loop after calling `client.loop()`.
}

void setup() {
  Serial.begin(115200);
  xTaskCreate(connect_wifi, "task_wifi", 4096, NULL, 10, &task_wifi);
}

void loop() {
  vTaskDelay(portMAX_DELAY);  // FreeRTOS tasks handle execution
}

